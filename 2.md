 
# Process
 program in execution

- Memory Layout
stack : local variables
heap : dynamic memory for allocate
data: global variables
text: code being executed

-**Process Control Block（PCB，进程控制块）** 是操作系统内核用来描述和管理每个进程的数据结构。每当操作系统创建一个新进程时，都会为该进程分配一个 PCB，用来存储与该进程相关的所有重要信息。
>每个thread亦有Thread Control Block (TCB)

-线程（Thread）是现代操作系统中一种重要的执行单元。它是**进程（Process）内部的一个轻量级执行流**，可以被视为操作系统资源的最小分配单元。
一个进程至少包含一个线程，称为**主线程（Main Thread）**。线程共享同一个进程的资源（如内存、文件描述符等），但它们有各自独立的运行上下文（如寄存器、程序计数器、栈等）。
>One process can have mutiple threads, but each thread only belongs to exactly one process

>**Differece between threads and process**
>The primary difference is that threads within the same process run in a shared memory space, while processes run in separate memory spaces.

## Process Scheduling 进程调度

decide the order where processes are executed by the CPU.
> ****Non-Preemptive**** 非抢占式
> **Preemptive** 抢占式

> **Each CPU core can run one process at a time**

 1. Scheduling Queues
when enter a system, the process be put into a **ready queue**, which is stored as a **linked list**; and when be interrupted, placed in a **wait queue**
 2. CPU Scheduling 
 is a process used by the operating system to decide which task or program gets to use the CPU at a particular time.
 > Cause one CPU can only handle one task at a time.
 > 
 *Turn Around Time 周转时间 = Completion Time – Arrival Time*
#### algorithms :
 1. First Come First Serve (FCFS)
 2. Shortest Job First (SJF)---having a minimum average waiting time, but may cause starvation.
 3. Longest Job First (LJF)
 4.  Priority Scheduling---starvation problem
 5. Round Robin 时间片轮转---most widely used
 6. Shortest Remaining Time First (SRTF)---根据剩余执行时间决定顺序
 7. Longest Remaining Time First (LRTF)
 8. Highest Response Ratio Next (HRRN)---non-preemptive & most optimal
 >****Response Ratio = (W + S)/S****
 >Here, ****W**** is the waiting time of the process so far and ****S**** is the Burst time of the process.
 
   9.Multiple Queue Scheduling
   10.Multilevel Feedback Queue Scheduling
>
>**Convoy Effect（车队效应）** 是操作系统中的一种资源调度问题，通常发生在 **批处理系统** 或 **时间片调度系统** 中。它指的是一个低效进程占用了资源，导致其他更高效的进程被迫等待，最终降低系统的整体性能。
>这种现象可以类比为一条路上的车队，其中**最慢的车**（低效进程）在前方行驶，后面的车（高效进程）因为无法超车而必须减速，整个车队的速度都被拖慢。

>many operating systems implement hybrid scheduling algorithms, just combined them
>**Context switching** is the process of storing the state of a currently running process and loading the state of another process.
>**Aging** is a technique used to prevent starvation in priority scheduling. It gradually increases the priority of a waiting process over time, ensuring that lower-priority processes eventually get CPU time.
>许多操作系统实现混合调度算法，只是将它们组合在一起
>上下文切换是存储当前正在运行的进程的状态并加载另一个进程的状态的过程。
老化是一种用于防止优先级调度中匮乏的技术。随着时间的推移，它会逐渐提高等待进程的优先级，从而确保优先级较低的进程最终获得 CPU 时间。

 ## process creation 进程创建
 a process (parent process) can create several new processes (the children of the process).
 大多数操作系统（包括 UNIX 、 Linux 和 Windows） 根据唯一的进程标识（或 pid）标识进程，该标识通常为整数。——process identifie

 - 

    #include<stdio.h>
    #include<unistd.h>
    #include<sys/types.h> 
    int value = 5;
	int main()
	{
    pid t pid;
    pid = fork();
    if (pid == 0) { /* child process */ 
		value += 15;
		return 0;
    }
    else if (pid > 0) { /* parent process */
        wait(NULL);
        printf("PARENT: value = %d",value); /* LINE A */
        return 0;
	    }
	}
value 是一个全局变量，初始值为 5。
它在父进程和子进程中都存在，但它们在各自的内存空间中独立操作。即，子进程对 value 的修改不会影响父进程中的 value。

fork() 会创建一个子进程：子进程 得到一个与父进程相同的内存副本（包括 value 的初始值）。
父进程 的 pid 为子进程的进程 ID（正整数）。
子进程 的 pid 为 0。
子进程和父进程的内存是独立的。

So what is the output of LINE A?

- 
`fork()` 是用来创建一个新进程的系统调用。每次调用 `fork()` 时，都会创建一个新的进程，新的进程是父进程的副本。
`fork()` 会创建一个新进程，返回值有两个：

-   **父进程**：`fork()` 返回新创建子进程的 PID（进程 ID）。
-   **子进程**：`fork()` 返回 `0`。

    #include <stdio.h> 
	#include <unistd.h>
	int main()
	{
    /* fork a child process */
    fork();
    /* fork another child process */
    fork();
    /* and fork another */
    fork();
    return 0;
	}
-   第一次 `fork()` 调用后，会创建一个子进程。此时系统中有两个进程：父进程和第一个子进程。
-   第二次 `fork()` 调用后，所有现有进程（父进程和第一个子进程）都会各自创建一个新子进程。所以总进程数会翻倍。
-   第三次 `fork()` 调用时，所有现有的进程（包括父进程和前面创建的所有子进程）会再次各自创建一个新的子进程，进程数再次翻倍。
### 进程创建的详细分析：

1.  **第一次 `fork()`**：
    
    -   父进程调用 `fork()`，创建一个子进程。
    -   此时有两个进程：父进程和第一个子进程。
2.  **第二次 `fork()`**：
    
    -   父进程和第一个子进程都调用 `fork()`。
    -   父进程创建第二个子进程，子进程创建第三个子进程。
    -   此时共有 4 个进程：父进程、第一个子进程、第二个子进程、第三个子进程。
3.  **第三次 `fork()`**：
    
    -   父进程、第一个子进程、第二个子进程、第三个子进程都调用 `fork()`。
    -   每个进程创建一个新的子进程。
    -   此时共有 8 个进程：父进程和 7 个子进程。
<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyJoVk5hRTJscWVVT2lDNlA2Ijp7In
N0YXJ0IjozNTQ5LCJlbmQiOjM1ODEsInRleHQiOiJTbyB3aGF0
IGlzIHRoZSBvdXRwdXQgb2YgTElORSBBPyJ9fSwiY29tbWVudH
MiOnsiM3k5dnZhdjNYMGx2d3V6WCI6eyJkaXNjdXNzaW9uSWQi
OiJoVk5hRTJscWVVT2lDNlA2Iiwic3ViIjoiZ286MTA1MjkxMz
A1NTEzODI5OTg5MDA3IiwidGV4dCI6IlBBUkVOVO+8miB2YWx1
ZSA9IDUiLCJjcmVhdGVkIjoxNzM0ODYwODQ5NTM4fSwiV2E4TG
xOdmgwY2lCUnFXQyI6eyJkaXNjdXNzaW9uSWQiOiJoVk5hRTJs
cWVVT2lDNlA2Iiwic3ViIjoiZ286MTA1MjkxMzA1NTEzODI5OT
g5MDA3IiwidGV4dCI6IlRoZSByZXN1bHQgaXMgc3RpbGwgNSwg
YXMgdGhlIGNoaWxkIHVwZGF0ZXMgaXRzIGNvcHkgb2YgdmFsdW
UuIFdoZW4gY29udHJvbCByZXR1cm5zIHRvIHRoZSBwYXJlbnQs
IGl0cyB2YWx1ZSByZW1haW5zIGF0IDUuIiwiY3JlYXRlZCI6MT
czNDg2MDg1Mzc5NH19LCJoaXN0b3J5IjpbMTc3MjMzODczMiwt
NDY4MDUwNjUsLTEwNDkyOTM2MjIsLTM1NzIyMDExMiwxMTEzNj
kzNzQ0LC0xMDUwNDY1NjE5LDg3NTgxMDU4MiwtMzI1MzUxMTUz
XX0=
-->