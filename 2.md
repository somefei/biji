 
# Process
 program in execution

- Memory Layout
stack : local variables
heap : dynamic memory for allocate
data: global variables
text: code being executed

-**Process Control Block（PCB，进程控制块）** 是操作系统内核用来描述和管理每个进程的数据结构。每当操作系统创建一个新进程时，都会为该进程分配一个 PCB，用来存储与该进程相关的所有重要信息。
>每个thread亦有Thread Control Block (TCB)

-线程（Thread）是现代操作系统中一种重要的执行单元。它是**进程（Process）内部的一个轻量级执行流**，可以被视为操作系统资源的最小分配单元。
一个进程至少包含一个线程，称为**主线程（Main Thread）**。线程共享同一个进程的资源（如内存、文件描述符等），但它们有各自独立的运行上下文（如寄存器、程序计数器、栈等）。
>One process can have mutiple threads, but each thread only belongs to exactly one process

>**Differece between threads and process**
>The primary difference is that threads within the same process run in a shared memory space, while processes run in separate memory spaces.

## Process Scheduling 进程调度

decide the order where processes are executed by the CPU.
> ****Non-Preemptive**** 非抢占式
> **Preemptive** 抢占式

> **Each CPU core can run one process at a time**

 1. Scheduling Queues
when enter a system, the process be put into a **ready queue**, which is stored as a **linked list**; and when be interrupted, placed in a **wait queue**
 2. CPU Scheduling 
 is a process used by the operating system to decide which task or program gets to use the CPU at a particular time.
 > Cause one CPU can only handle one task at a time.
 > 
 *Turn Around Time 周转时间 = Completion Time – Arrival Time*
#### algorithms :
 1. First Come First Serve (FCFS)
 2. Shortest Job First (SJF)---having a minimum average waiting time, but may cause starvation.
 3. Longest Job First (LJF)
 4.  Priority Scheduling---starvation problem
 5. Round Robin 时间片轮转---most widely used
 6. Shortest Remaining Time First (SRTF)---根据剩余执行时间决定顺序
 7. Longest Remaining Time First (LRTF)
 8. Highest Response Ratio Next (HRRN)---non-preemptive & most optimal
 >****Response Ratio = (W + S)/S****
 >Here, ****W**** is the waiting time of the process so far and ****S**** is the Burst time of the process.
 
   9.Multiple Queue Scheduling
   10.Multilevel Feedback Queue Scheduling
>
>**Convoy Effect（车队效应）** 是操作系统中的一种资源调度问题，通常发生在 **批处理系统** 或 **时间片调度系统** 中。它指的是一个低效进程占用了资源，导致其他更高效的进程被迫等待，最终降低系统的整体性能。
>这种现象可以类比为一条路上的车队，其中**最慢的车**（低效进程）在前方行驶，后面的车（高效进程）因为无法超车而必须减速，整个车队的速度都被拖慢。

>many operating systems implement hybrid scheduling algorithms, just combined them
>**Context switching** is the process of storing the state of a currently running process and loading the state of another process.
>**Aging** is a technique used to prevent starvation in priority scheduling. It gradually increases the priority of a waiting process over time, ensuring that lower-priority processes eventually get CPU time.
>许多操作系统实现混合调度算法，只是将它们组合在一起
>上下文切换是存储当前正在运行的进程的状态并加载另一个进程的状态的过程。
老化是一种用于防止优先级调度中匮乏的技术。随着时间的推移，它会逐渐提高等待进程的优先级，从而确保优先级较低的进程最终获得 CPU 时间。

 ## process creation 进程创建
 a process (parent process) can create several new processes (the children of the process).
 大多数操作系统（包括 UNIX 、 Linux 和 Windows） 根据唯一的进程标识（或 pid）标识进程，该标识通常为整数。——process identifie

 -

    #include<stdio.h>
    #include<unistd.h>
    #include<sys/types.h> 
    int value = 5;
	int main()
	{
    pid t pid;
    pid = fork();
    if (pid == 0) { /* child process */ 
		value += 15;
		return 0;
    }
    else if (pid > 0) { /* parent process */
        wait(NULL);
        printf("PARENT: value = %d",value); /* LINE A */
        return 0;
	    }
	}
value 是一个全局变量，初始值为 5。
它在父进程和子进程中都存在，但它们在各自的内存空间中独立操作。即，子进程对 value 的修改不会影响父进程中的 value。

fork() 会创建一个子进程：子进程 得到一个与父进程相同的内存副本（包括 value 的初始值）。
父进程 的 pid 为子进程的进程 ID（正整数）。
子进程 的 pid 为 0。
子进程和父进程的内存是独立的。

So what is the output of LINE A?

- 
`fork()` 是用来创建一个新进程的系统调用。每次调用 `fork()` 时，都会创建一个新的进程，新的进程是父进程的副本。
`fork()` 会创建一个新进程，返回值有两个：

-   **父进程**：`fork()` 返回新创建子进程的 PID（进程 ID）。
-   **子进程**：`fork()` 返回 `0`。

	    #include <stdio.h> 
		#include <unistd.h>
		int main()
		{
	    /* fork a child process */
	    fork();
	    /* fork another child process */
	    fork();
	    /* and fork another */
	    fork();
	    return 0;
		}
第一次 `fork()` 调用后，会创建一个子进程。此时系统中有两个进程：父进程和第一个子进程。
第二次 `fork()` 调用后，所有现有进程（父进程和第一个子进程）都会各自创建一个新子进程。所以总进程数会翻倍。
第三次 `fork()` 调用时，所有现有的进程（包括父进程和前面创建的所有子进程）会再次各自创建一个新的子进程，进程数再次翻倍。
### 进程创建的详细分析：

1.  **第一次 `fork()`**：
    
    -   父进程调用 `fork()`，创建一个子进程。
    -   此时有两个进程：父进程和第一个子进程。
2.  **第二次 `fork()`**：
    
    -   父进程和第一个子进程都调用 `fork()`。
    -   父进程创建第二个子进程，子进程创建第三个子进程。
    -   此时共有 4 个进程：父进程、第一个子进程、第二个子进程、第三个子进程。
3.  **第三次 `fork()`**：
    
    -   父进程、第一个子进程、第二个子进程、第三个子进程都调用 `fork()`。
    -   每个进程创建一个新的子进程。
    -   此时共有 8 个进程：父进程和 7 个子进程。
   
  So including the initial parent process, how many processes are created by the program?

- **concurrent processing** 并发处理
> ### **并发进程是什么？**
> **并发**简单来说就是**“同时干很多事情”**。
举个例子：
.-   假如你是一个厨师，要同时煮饭、炒菜、煮汤。
    -   **煮饭**：米放锅里，让它煮着；
    -   **炒菜**：切菜、下锅翻炒；
    -   **煮汤**：水烧开，加入食材，慢慢炖。
你并不是“三头六臂”，而是**每件事轮流干一点**：
.1.  先把饭放锅里开始煮；
.2.  再切菜炒菜；
.3.  等汤烧开再去看一眼饭煮得怎么样。
>这就是并发进程！虽然每个时刻你只做一件事，但看起来就像你同时在煮饭、炒菜和煮汤。

----------

> ### **计算机里的并发进程**
> 
> 在电脑中：
> 
> 1.  一个进程是一个任务，比如“播放音乐”或“下载文件”。
> 2.  如果电脑只有一个CPU（就像只有一个厨师），它会像上面那样轮流干：
>     -   播放一小段音乐；
>     -   下载一点文件；
>     -   再回来播放下一小段音乐。
> 
> **结果**：虽然它是轮流干的，但速度很快，给我们的感觉就是“同时播放音乐”和“下载文件”。
在并发中，有几个问题需要注意：
> 
> 1.  **共享资源问题**  
>     假如两个进程同时修改一笔钱：
>     
>     -   进程A：要把钱取出来买东西；
>     -   进程B：要把钱取出来存到另一个账户。
>     
>     如果没有协调好，可能会出错（比如钱不翼而飞）。  
>     **解决方法**：需要“锁”来保证每次只能一个进程操作这笔钱。
>     
> 2.  **死锁（Deadlock）**  
>     假如两个进程同时需要两把钥匙：
>     
>     -   进程A拿了一把钥匙，等着另一把；
>     -   进程B拿了另一把钥匙，等着进程A的钥匙。
>     
>     两个进程都在等对方，谁也干不了活。  
>     **解决方法**：设计好规则，避免这种情况。
> >>>>### 总结
> 
> 1.  并发就是**轮流干活，看起来像同时干**。
> 2.  计算机利用并发提高效率，让多个任务“同时”运行。
> 3.  需要注意共享资源和死锁问题。

Concurrent Processes（并发进程）是指在同一时间段内，由操作系统调度和管理的多个进程，它们可能在同一时刻并行执行，也可能交替执行，但对用户来说，它们似乎是同时进行的。
并发性是多任务处理的一种形式，~~它允许多个任务（或进程）在计算机中共享资源，例如 CPU、内存和输入输出设备。~~并发进程的主要特征是在时间上重叠执行，而不一定是并行执行（即不一定同时在不同的处理器核心上执行）
**并发与并行的区别**

-   **并发（Concurrency）**：  
    轮流干活，像一个厨师切换任务，表面看起来同时在做。
    
-   **并行（Parallelism）**：  
    多个厨师（多核CPU）同时干活，比如一个厨师炒菜，一个厨师煮饭，真的同时进行。

Original versions of Apple’s mobile iOS operating system provided no means of concurrent processing. Discuss three major complications that concurrent processing adds to an operating system.

- **register set** 寄存器组
- **context switch** 上下文切换


1.  **保存当前进程的状态**：当操作系统决定从进程A切换到进程B时，它需要保存进程A的当前状态，包括寄存器内容、程序计数器（指向下一条指令的地址）、内存信息等。这些状态信息被保存在**进程控制块**（PCB）中。
    
2.  **加载下一个进程的状态**：然后，操作系统会加载进程B的状态，恢复进程B之前保存的信息，如寄存器的值、程序计数器等，准备进程B继续执行。
    
3.  **继续执行**：完成切换后，进程B就开始执行，直到操作系统决定切换到其他进程。
Some computer systems provide multiple register sets. Describe what happens when a context switch occurs if the new context is already loaded into one of the register sets. What happens if the new context is in memory rather than in a register set and all the register sets are in use?

- 

> 当进程使用 `fork()`
> 操作创建新进程时，**父进程**和**子进程**之间会共享一些状态，但并不是所有的状态都是共享的。为了简单理解，我们可以分为**共享的状态**和**不共享的状态**。
> 
> ### **1. 共享的状态：**
> 
> 父进程和子进程在 `fork()` 时，**共享**以下几种状态：
> 
> -   **文件描述符**：父进程和子进程会共享打开的文件描述符。文件描述符是指向文件、设备或其他输入输出流的标识符。两者共享同一份文件描述符表，因此它们对同一个文件的操作会影响对方。例如，如果父进程或子进程修改文件指针的位置，另一个进程也会看到相同的变化。
>     
> -   **文件映射**：如果父进程和子进程都有对某个文件的内存映射（通过 `mmap()` 等函数），它们也会共享这些内存区域。这意味着如果其中一个进程修改映射内存中的数据，另一个进程也能看到变化。
>     
> 
> ### **2. 不共享的状态：**
> 
> 父进程和子进程之间，**大部分其他状态**都是不共享的，包括：
> 
> -   **进程ID（PID）**：父进程和子进程的进程ID是不同的，父进程的PID与子进程的PID不同。
>     
> -   **寄存器状态**：每个进程有自己的寄存器组，包括程序计数器、堆栈指针等。`fork()` 后，父进程和子进程分别拥有自己独立的寄存器值。
>     
> -   **内存空间**：`fork()` 会为子进程创建一份**父进程的内存副本**，父进程和子进程有各自独立的内存空间。虽然内存内容一开始是一样的，但它们是独立的，修改其中一个进程的内存不会影响另一个进程。
>     
> -   **进程状态（比如执行状态、调度信息等）**：父进程和子进程的执行状态、调度信息等都是独立的。例如，父进程在 `fork()` 后继续执行，而子进程从 `fork()` 调用的返回点开始执行。
>     
> 
> ### **总结：**
> 
> -   **共享的状态**：
>     -   文件描述符
>     -   文件映射
> -   **不共享的状态**：
>     -   进程ID（PID）
>     -   寄存器状态
>     -   内存空间
>     -   进程状态（执行状态、调度信息等）
> 
> ### **举个例子：**
> 
> 想象你有两个兄弟（父进程和子进程）：
> 
> -   他们有各自的身份证（PID），虽然长得像（内存复制），但每个人有自己独立的身份证。
> -   他们共享的东西是两人共同买的电视遥控器（文件描述符）。如果其中一个人调整了音量，另一个人也会看到改变。

当进程使用 `fork()` 操作创建新进程时，父进程和子进程之间共享的状态是：

**c. 共享内存段**

### 解释：

-   **a. 堆栈**：父进程和子进程各自有自己的独立堆栈。在 `fork()` 操作时，子进程会复制父进程的堆栈，因此它们是独立的，修改一个进程的堆栈内容不会影响另一个进程的堆栈。
    
-   **b. 堆**：同样，父进程和子进程也有独立的堆空间。`fork()` 后，堆是被复制的，虽然初始时堆的内容是一样的，但它们各自拥有独立的内存区域，因此修改一个进程的堆不会影响另一个进程。
    
-   **c. 共享内存段**：如果父进程和子进程通过特定的方式（比如 `shmget()` 和 `shmat()` 等）使用共享内存，那么它们就可以访问共享内存段。在 `fork()` 后，父进程和子进程共享这些内存段，因此修改共享内存中的数据，两个进程都能看到变化。
    

### **总结**：

-   `fork()` 创建的新进程会复制父进程的内存空间，但**堆栈和堆**是独立的。
-   通过共享内存段，父进程和子进程可以共享数据。
<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyJoVk5hRTJscWVVT2lDNlA2Ijp7In
N0YXJ0IjozNTQ4LCJlbmQiOjM1ODAsInRleHQiOiJTbyB3aGF0
IGlzIHRoZSBvdXRwdXQgb2YgTElORSBBPyJ9LCJhZU9laEFJcV
RqdnNpOG5JIjp7InN0YXJ0Ijo0NTE4LCJlbmQiOjQ2MDUsInRl
eHQiOiJTbyBpbmNsdWRpbmcgdGhlIGluaXRpYWwgcGFyZW50IH
Byb2Nlc3MsIGhvdyBtYW55IHByb2Nlc3NlcyBhcmUgY3JlYXRl
ZCBieSB0aGXigKYifSwiT3dWNWNoaW1xZVJLSndXSSI6eyJzdG
FydCI6NTk3NCwiZW5kIjo2MTY0LCJ0ZXh0IjoiT3JpZ2luYWwg
dmVyc2lvbnMgb2YgQXBwbGXigJlzIG1vYmlsZSBpT1Mgb3Blcm
F0aW5nIHN5c3RlbSBwcm92aWRlZCBubyBtZWFucyBvZiBj4oCm
In0sIjZja3Aydk9rd2NVOVZsYkYiOnsic3RhcnQiOjY0NTgsIm
VuZCI6Njc0MywidGV4dCI6IlNvbWUgY29tcHV0ZXIgc3lzdGVt
cyBwcm92aWRlIG11bHRpcGxlIHJlZ2lzdGVyIHNldHMuIERlc2
NyaWJlIHdoYXQgaGFwcGVucyB3aGXigKYifX0sImNvbW1lbnRz
Ijp7IjN5OXZ2YXYzWDBsdnd1elgiOnsiZGlzY3Vzc2lvbklkIj
oiaFZOYUUybHFlVU9pQzZQNiIsInN1YiI6ImdvOjEwNTI5MTMw
NTUxMzgyOTk4OTAwNyIsInRleHQiOiJQQVJFTlTvvJogdmFsdW
UgPSA1IiwiY3JlYXRlZCI6MTczNDg2MDg0OTUzOH0sIldhOExs
TnZoMGNpQlJxV0MiOnsiZGlzY3Vzc2lvbklkIjoiaFZOYUUybH
FlVU9pQzZQNiIsInN1YiI6ImdvOjEwNTI5MTMwNTUxMzgyOTk4
OTAwNyIsInRleHQiOiJUaGUgcmVzdWx0IGlzIHN0aWxsIDUsIG
FzIHRoZSBjaGlsZCB1cGRhdGVzIGl0cyBjb3B5IG9mIHZhbHVl
LiBXaGVuIGNvbnRyb2wgcmV0dXJucyB0byB0aGUgcGFyZW50LC
BpdHMgdmFsdWUgcmVtYWlucyBhdCA1LiIsImNyZWF0ZWQiOjE3
MzQ4NjA4NTM3OTR9LCI0R2RqeVBoRFlLVk9iSTJyIjp7ImRpc2
N1c3Npb25JZCI6ImFlT2VoQUlxVGp2c2k4bkkiLCJzdWIiOiJn
bzoxMDUyOTEzMDU1MTM4Mjk5ODkwMDciLCJ0ZXh0IjoiOCIsIm
NyZWF0ZWQiOjE3MzQ4NjE2NTEzNjJ9LCJDRVk1ekI1S1ZCUTJ5
cGU2Ijp7ImRpc2N1c3Npb25JZCI6Ik93VjVjaGltcWVSS0p3V0
kiLCJzdWIiOiJnbzoxMDUyOTEzMDU1MTM4Mjk5ODkwMDciLCJ0
ZXh0IjoiVGhlIENQVSBzY2hlZHVsZXIgbXVzdCBiZSBhd2FyZS
BvZiB0aGUgZGlmZmVyZW50IGNvbmN1cnJlbnQgcHJvY2Vzc2Vz
IGFuZCBtdXN0IGNob29zZSBhbiBhcHByb3ByaWF0ZSBhbGdvcm
l0aG0gdGhhdCBzY2hlZHVsZXMgdGhlIGNvbmN1cnJlbnQgcHJv
Y2Vzc2VzLkNQVeiwg+W6puWZqOmcgOimgeS6huino+S4jeWQjO
eahOW5tuWPkei/m+eoi++8jOW5tumAieaLqeWQiOmAgueahOeu
l+azleadpeiwg+W6pui/meS6m+i/m+eoi+OAgiIsImNyZWF0ZW
QiOjE3MzQ5OTgzNjE2ODh9LCJrN0I0TFN5bXRPeUhwNUpVIjp7
ImRpc2N1c3Npb25JZCI6Ik93VjVjaGltcWVSS0p3V0kiLCJzdW
IiOiJnbzoxMDUyOTEzMDU1MTM4Mjk5ODkwMDciLCJ0ZXh0Ijoi
5bm25Y+R6L+b56iL5Y+v6IO96ZyA6KaB55u45LqS6YCa5L+h77
yM5Zug5q2k5pON5L2c57O757uf5b+F6aG75o+Q5L6b5LiA56eN
5oiW5aSa56eN6L+b56iL6Ze06YCa5L+h55qE5pa55rOV44CCQ2
9uY3VycmVudCBwcm9jZXNzZXMgbWF5IG5lZWQgdG8gY29tbXVu
aWNhdGUgd2l0aCBvbmUgYW5vdGhlciwgYW5kIHRoZSBvcGVyYX
Rpbmcgc3lzdGVtIG11c3QgdGhlcmVmb3JlIGRldmVsb3Agb25l
IG9yIG1vcmUgbWV0aG9kcyBmb3IgcHJvdmlkaW5nIGludGVycH
JvY2VzcyBjb21tdW5pY2F0aW9uLioq6L+b56iL6Ze06YCa5L+h
77yISVBDLCBJbnRlci1Qcm9jZXNzIENvbW11bmljYXRpb27vvI
kqKu+8muWwseaYr+W9k+S4gOS4qui/m+eoi+mcgOimgeWSjOWP
puS4gOS4qui/m+eoi+S6pOaNouS/oeaBr+aXtu+8jOaTjeS9nO
ezu+e7n+mcgOimgeaPkOS+m+S4gOenjeaWueW8j+iuqeWug+S7
rOayn+mAmuOAgiIsImNyZWF0ZWQiOjE3MzQ5OTg2NzM3NzZ9LC
Jhc3JCQ2pHTEhvWlRIOW82Ijp7ImRpc2N1c3Npb25JZCI6Ik93
VjVjaGltcWVSS0p3V0kiLCJzdWIiOiJnbzoxMDUyOTEzMDU1MT
M4Mjk5ODkwMDciLCJ0ZXh0Ijoi55Sx5LqO56e75Yqo6K6+5aSH
6YCa5bi45YaF5a2Y5pyJ6ZmQ77yM566h55CG5LiN5ZaE55qE6L
+b56iL5Lya5a+55YW25LuW5bm25Y+R6L+b56iL5Lqn55Sf6LSf
6Z2i5b2x5ZON44CC5Zug5q2k77yM5pON5L2c57O757uf5b+F6a
G7566h55CG5YaF5a2Y77yM5Lul5pSv5oyB5aSa5Liq5bm25Y+R
6L+b56iL44CCQmVjYXVzZSBtb2JpbGUgZGV2aWNlcyBvZnRlbi
BoYXZlIGxpbWl0ZWQgbWVtb3J5LCBhIHByb2Nlc3MgdGhhdCBt
YW5hZ2VzIG1lbW9yeSBwb29ybHkgd2lsbCBoYXZlIGFuIG92ZX
JhbGwgbmVnYXRpdmUgaW1wYWN0IG9uIG90aGVyIGNvbmN1cnJl
bnQgcHJvY2Vzc2VzLiBUaGUgb3BlcmF0aW5nIHN5c3RlbSBtdX
N0IHRoZXJlZm9yZSBtYW5hZ2UgbWVtb3J5IHRvIHN1cHBvcnQg
bXVsdGlwbGUgY29uY3VycmVudCBwcm9jZXNzZXMuIiwiY3JlYX
RlZCI6MTczNDk5ODk3NTc1OX0sIlR2WWwzb2lxd1IydHFnTGsi
OnsiZGlzY3Vzc2lvbklkIjoiNmNrcDJ2T2t3Y1U5VmxiRiIsIn
N1YiI6ImdvOjEwNTI5MTMwNTUxMzgyOTk4OTAwNyIsInRleHQi
OiLvvIjnkIbop6PlsLHlpb3vvIzov5nmnKzkuabnmoTnrZTmoY
jpg73kuI3lpKrooYzvvIlDUFUg5b2T5YmN5a+E5a2Y5Zmo6ZuG
5oyH6ZKI6KKr5pu05pS55Li65oyH5ZCR5YyF5ZCr5paw5LiK5L
iL5paH55qE6ZuG5ZCI77yM6L+Z6ZyA6KaB5b6I5bCR55qE5pe2
6Ze044CC5aaC5p6c5LiK5LiL5paH5Zyo5YaF5a2Y5Lit77yM5Y
iZ5b+F6aG76YCJ5oup5a+E5a2Y5Zmo6ZuG5Lit55qE5LiA5Liq
5LiK5LiL5paH5bm25bCG5YW256e75Yqo5Yiw5YaF5a2Y5Lit77
yM5bm25LiU5b+F6aG75bCG5paw5LiK5LiL5paH5LuO5YaF5a2Y
5Yqg6L295Yiw6K+l6ZuG5ZCI5Lit44CC6L+Z5Liq6L+H56iL5q
+U5Zyo5YW35pyJ5LiA57uE5a+E5a2Y5Zmo55qE57O757uf5LiK
6Iqx6LS555qE5pe26Ze056iN6ZW/77yM5YW35L2T5Y+W5Yaz5L
qO5aaC5L2V6YCJ5oup5pu/5o2i54m654my5ZOB44CCVGhlIENQ
VSBjdXJyZW50LXJlZ2lzdGVyLXNldCBwb2ludGVyIGlzIGNoYW
5nZWQgdG8gcG9pbnQgdG8gdGhlIHNldCBjb24tIHRhaW5pbmcg
dGhlIG5ldyBjb250ZXh0LCB3aGljaCB0YWtlcyB2ZXJ5IGxpdH
RsZSB0aW1lLiBJZiB0aGUgY29udGV4dCBpcyBpbiBtZW1vcnks
IG9uZSBvZiB0aGUgY29udGV4dHMgaW4gYSByZWdpc3RlciBzZX
QgbXVzdCBiZSBjaG9zZW4gYW5kIGJlIG1vdmVkIHRvIG1lbW9y
eSwgYW5kIHRoZSBuZXcgY29udGV4dCBtdXN0IGJlIGxvYWRlZC
Bmcm9tIG1lbW9yeSBpbnRvIHRoZSBzZXQuIFRoaXMgcHJvY2Vz
cyB0YWtlcyBhIGxpdHRsZSBtb3JlIHRpbWUgdGhhbiBvbiBzeX
N0ZW1zIHdpdGggb25lIHNldCBvZiByZWdpc3RlcnMsIGRlcGVu
ZGluZyBvbiBob3cgYSByZXBsYWNlbWVudCB2aWN0aW0gaXMgc2
VsZWN0ZWQuIiwiY3JlYXRlZCI6MTczNTAwMDEzOTU2MH19LCJo
aXN0b3J5IjpbLTEyODYyODQ1MzAsMTU1ODMwMDY2LC0xNDkxOT
Q5OTE3LC05NDAyOTI2OCwyMTA2MTY1MzM2LDIxMzc0MTc2NjUs
LTQzMjI5NTE1NywtMTk4NjE3MzcxMiwtMTM1MTY1MzE1MiwxNj
U1NTc0MjkwLDEwMDExMTAwMjgsLTE5NzA0NzMyMzksLTQ2ODA1
MDY1LC0xMDQ5MjkzNjIyLC0zNTcyMjAxMTIsMTExMzY5Mzc0NC
wtMTA1MDQ2NTYxOSw4NzU4MTA1ODIsLTMyNTM1MTE1M119
-->