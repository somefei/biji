 
# Process
 program in execution

- Memory Layout
stack : local variables
heap : dynamic memory for allocate
data: global variables
text: code being executed

-**Process Control Block（PCB，进程控制块）** 是操作系统内核用来描述和管理每个进程的数据结构。每当操作系统创建一个新进程时，都会为该进程分配一个 PCB，用来存储与该进程相关的所有重要信息。
>每个thread亦有Thread Control Block (TCB)

-线程（Thread）是现代操作系统中一种重要的执行单元。它是**进程（Process）内部的一个轻量级执行流**，可以被视为操作系统资源的最小分配单元。
一个进程至少包含一个线程，称为**主线程（Main Thread）**。线程共享同一个进程的资源（如内存、文件描述符等），但它们有各自独立的运行上下文（如寄存器、程序计数器、栈等）。
>One process can have mutiple threads, but each thread only belongs to exactly one process

>**Differece between threads and process**
>The primary difference is that threads within the same process run in a shared memory space, while processes run in separate memory spaces.

## Process Scheduling 进程调度

decide the order where processes are executed by the CPU.
> ****Non-Preemptive**** 非抢占式
> **Preemptive** 抢占式

> **Each CPU core can run one process at a time**

 1. Scheduling Queues
when enter a system, the process be put into a **ready queue**, which is stored as a **linked list**; and when be interrupted, placed in a **wait queue**
 2. CPU Scheduling 
 is a process used by the operating system to decide which task or program gets to use the CPU at a particular time.
 > Cause one CPU can only handle one task at a time.
 > 
 *Turn Around Time 周转时间 = Completion Time – Arrival Time*
#### algorithms :
 1. First Come First Serve (FCFS)
 2. Shortest Job First (SJF)---having a minimum average waiting time, but may cause starvation.
 3. Longest Job First (LJF)
 4.  Priority Scheduling---starvation problem
 5. Round Robin 时间片轮转---most widely used
 6. Shortest Remaining Time First (SRTF)---根据剩余执行时间决定顺序
 7. Longest Remaining Time First (LRTF)
 8. Highest Response Ratio Next (HRRN)---non-preemptive & most optimal
 >****Response Ratio = (W + S)/S****
 >Here, ****W**** is the waiting time of the process so far and ****S**** is the Burst time of the process.
 
   9.Multiple Queue Scheduling
   10.Multilevel Feedback Queue Scheduling
>
>**Convoy Effect（车队效应）** 是操作系统中的一种资源调度问题，通常发生在 **批处理系统** 或 **时间片调度系统** 中。它指的是一个低效进程占用了资源，导致其他更高效的进程被迫等待，最终降低系统的整体性能。
>这种现象可以类比为一条路上的车队，其中**最慢的车**（低效进程）在前方行驶，后面的车（高效进程）因为无法超车而必须减速，整个车队的速度都被拖慢。

>many operating systems implement hybrid scheduling algorithms, just combined them
>**Context switching** is the process of storing the state of a currently running process and loading the state of another process.
>**Aging** is a technique used to prevent starvation in priority scheduling. It gradually increases the priority of a waiting process over time, ensuring that lower-priority processes eventually get CPU time.
>许多操作系统实现混合调度算法，只是将它们组合在一起
>上下文切换是存储当前正在运行的进程的状态并加载另一个进程的状态的过程。
老化是一种用于防止优先级调度中匮乏的技术。随着时间的推移，它会逐渐提高等待进程的优先级，从而确保优先级较低的进程最终获得 CPU 时间。

 ## process creation 进程创建
 a process (parent process) can create several new processes (the children of the process).
 大多数操作系统（包括 UNIX 、 Linux 和 Windows） 根据唯一的进程标识（或 pid）标识进程，该标识通常为整数。——process identifie

 -

    #include<stdio.h>
    #include<unistd.h>
    #include<sys/types.h> 
    int value = 5;
	int main()
	{
    pid t pid;
    pid = fork();
    if (pid == 0) { /* child process */ 
		value += 15;
		return 0;
    }
    else if (pid > 0) { /* parent process */
        wait(NULL);
        printf("PARENT: value = %d",value); /* LINE A */
        return 0;
	    }
	}
value 是一个全局变量，初始值为 5。
它在父进程和子进程中都存在，但它们在各自的内存空间中独立操作。即，子进程对 value 的修改不会影响父进程中的 value。

fork() 会创建一个子进程：子进程 得到一个与父进程相同的内存副本（包括 value 的初始值）。
父进程 的 pid 为子进程的进程 ID（正整数）。
子进程 的 pid 为 0。
子进程和父进程的内存是独立的。

So what is the output of LINE A?

- 
`fork()` 是用来创建一个新进程的系统调用。每次调用 `fork()` 时，都会创建一个新的进程，新的进程是父进程的副本。
`fork()` 会创建一个新进程，返回值有两个：

-   **父进程**：`fork()` 返回新创建子进程的 PID（进程 ID）。
-   **子进程**：`fork()` 返回 `0`。

	    #include <stdio.h> 
		#include <unistd.h>
		int main()
		{
	    /* fork a child process */
	    fork();
	    /* fork another child process */
	    fork();
	    /* and fork another */
	    fork();
	    return 0;
		}
第一次 `fork()` 调用后，会创建一个子进程。此时系统中有两个进程：父进程和第一个子进程。
第二次 `fork()` 调用后，所有现有进程（父进程和第一个子进程）都会各自创建一个新子进程。所以总进程数会翻倍。
第三次 `fork()` 调用时，所有现有的进程（包括父进程和前面创建的所有子进程）会再次各自创建一个新的子进程，进程数再次翻倍。
### 进程创建的详细分析：

1.  **第一次 `fork()`**：
    
    -   父进程调用 `fork()`，创建一个子进程。
    -   此时有两个进程：父进程和第一个子进程。
2.  **第二次 `fork()`**：
    
    -   父进程和第一个子进程都调用 `fork()`。
    -   父进程创建第二个子进程，子进程创建第三个子进程。
    -   此时共有 4 个进程：父进程、第一个子进程、第二个子进程、第三个子进程。
3.  **第三次 `fork()`**：
    
    -   父进程、第一个子进程、第二个子进程、第三个子进程都调用 `fork()`。
    -   每个进程创建一个新的子进程。
    -   此时共有 8 个进程：父进程和 7 个子进程。
   
  So including the initial parent process, how many processes are created by the program?

- **concurrent processing** 并发处理

Concurrent Processes（并发进程）是指在同一时间段内，由操作系统调度和管理的多个进程，它们可能在同一时刻并行执行，也可能交替执行，但对用户来说，它们似乎是同时进行的。
并发性是多任务处理的一种形式，它允许多个任务（或进程）在计算机中共享资源，例如 CPU、内存和输入输出设备。并发进程的主要特征是在时间上重叠执行，而不一定是并行执行（即不一定同时在不同的处理器核心上执行）
**并发与并行的区别**

-   **并发（Concurrency）**：  
    轮流干活，像一个厨师切换任务，表面看起来同时在做。
    
-   **并行（Parallelism）**：  
    多个厨师（多核CPU）同时干活，比如一个厨师炒菜，一个厨师煮饭，真的同时进行。
<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyJoVk5hRTJscWVVT2lDNlA2Ijp7In
N0YXJ0IjozNTQ4LCJlbmQiOjM1ODAsInRleHQiOiJTbyB3aGF0
IGlzIHRoZSBvdXRwdXQgb2YgTElORSBBPyJ9LCJhZU9laEFJcV
RqdnNpOG5JIjp7InN0YXJ0Ijo0NTE4LCJlbmQiOjQ2MDUsInRl
eHQiOiJTbyBpbmNsdWRpbmcgdGhlIGluaXRpYWwgcGFyZW50IH
Byb2Nlc3MsIGhvdyBtYW55IHByb2Nlc3NlcyBhcmUgY3JlYXRl
ZCBieSB0aGXigKYifX0sImNvbW1lbnRzIjp7IjN5OXZ2YXYzWD
Bsdnd1elgiOnsiZGlzY3Vzc2lvbklkIjoiaFZOYUUybHFlVU9p
QzZQNiIsInN1YiI6ImdvOjEwNTI5MTMwNTUxMzgyOTk4OTAwNy
IsInRleHQiOiJQQVJFTlTvvJogdmFsdWUgPSA1IiwiY3JlYXRl
ZCI6MTczNDg2MDg0OTUzOH0sIldhOExsTnZoMGNpQlJxV0MiOn
siZGlzY3Vzc2lvbklkIjoiaFZOYUUybHFlVU9pQzZQNiIsInN1
YiI6ImdvOjEwNTI5MTMwNTUxMzgyOTk4OTAwNyIsInRleHQiOi
JUaGUgcmVzdWx0IGlzIHN0aWxsIDUsIGFzIHRoZSBjaGlsZCB1
cGRhdGVzIGl0cyBjb3B5IG9mIHZhbHVlLiBXaGVuIGNvbnRyb2
wgcmV0dXJucyB0byB0aGUgcGFyZW50LCBpdHMgdmFsdWUgcmVt
YWlucyBhdCA1LiIsImNyZWF0ZWQiOjE3MzQ4NjA4NTM3OTR9LC
I0R2RqeVBoRFlLVk9iSTJyIjp7ImRpc2N1c3Npb25JZCI6ImFl
T2VoQUlxVGp2c2k4bkkiLCJzdWIiOiJnbzoxMDUyOTEzMDU1MT
M4Mjk5ODkwMDciLCJ0ZXh0IjoiOCIsImNyZWF0ZWQiOjE3MzQ4
NjE2NTEzNjJ9fSwiaGlzdG9yeSI6WzEyMzc0NzE3ODQsLTEzNT
E2NTMxNTIsMTY1NTU3NDI5MCwxMDAxMTEwMDI4LC0xOTcwNDcz
MjM5LC00NjgwNTA2NSwtMTA0OTI5MzYyMiwtMzU3MjIwMTEyLD
ExMTM2OTM3NDQsLTEwNTA0NjU2MTksODc1ODEwNTgyLC0zMjUz
NTExNTNdfQ==
-->