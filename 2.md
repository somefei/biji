 
# Process
 program in execution

- Memory Layout
stack : local variables
heap : dynamic memory for allocate
data: global variables
text: code being executed

-**Process Control Block（PCB，进程控制块）** 是操作系统内核用来描述和管理每个进程的数据结构。每当操作系统创建一个新进程时，都会为该进程分配一个 PCB，用来存储与该进程相关的所有重要信息。
>每个thread亦有Thread Control Block (TCB)

-线程（Thread）是现代操作系统中一种重要的执行单元。它是**进程（Process）内部的一个轻量级执行流**，可以被视为操作系统资源的最小分配单元。
一个进程至少包含一个线程，称为**主线程（Main Thread）**。线程共享同一个进程的资源（如内存、文件描述符等），但它们有各自独立的运行上下文（如寄存器、程序计数器、栈等）。
>One process can have mutiple threads, but each thread only belongs to exactly one process

>**Differece between threads and process**
>The primary difference is that threads within the same process run in a shared memory space, while processes run in separate memory spaces.

## Process Scheduling 进程调度

decide the order where processes are executed by the CPU.
> ****Non-Preemptive**** 非抢占式
> **Preemptive** 抢占式

> **Each CPU core can run one process at a time**

 1. Scheduling Queues
when enter a system, the process be put into a **ready queue**, which is stored as a **linked list**; and when be interrupted, placed in a **wait queue**
 2. CPU Scheduling 
 is a process used by the operating system to decide which task or program gets to use the CPU at a particular time.
 > Cause one CPU can only handle one task at a time.
 > 
 *Turn Around Time 周转时间 = Completion Time – Arrival Time*
#### algorithms :
 1. First Come First Serve (FCFS)
 2. Shortest Job First (SJF)---having a minimum average waiting time, but may cause starvation.
 3. Longest Job First (LJF)
 4.  Priority Scheduling---starvation problem
 5. Round Robin 时间片轮转---most widely used
 6. Shortest Remaining Time First (SRTF)---根据剩余执行时间决定顺序
 7. Longest Remaining Time First (LRTF)
 8. Highest Response Ratio Next (HRRN)---non-preemptive & most optimal
 >****Response Ratio = (W + S)/S****
 >Here, ****W**** is the waiting time of the process so far and ****S**** is the Burst time of the process.
 
   9.Multiple Queue Scheduling
   10.Multilevel Feedback Queue Scheduling
>
>**Convoy Effect（车队效应）** 是操作系统中的一种资源调度问题，通常发生在 **批处理系统** 或 **时间片调度系统** 中。它指的是一个低效进程占用了资源，导致其他更高效的进程被迫等待，最终降低系统的整体性能。
>这种现象可以类比为一条路上的车队，其中**最慢的车**（低效进程）在前方行驶，后面的车（高效进程）因为无法超车而必须减速，整个车队的速度都被拖慢。

>many operating systems implement hybrid scheduling algorithms, just combined them
>**Context switching** is the process of storing the state of a currently running process and loading the state of another process.
>**Aging** is a technique used to prevent starvation in priority scheduling. It gradually increases the priority of a waiting process over time, ensuring that lower-priority processes eventually get CPU time.
>许多操作系统实现混合调度算法，只是将它们组合在一起
>上下文切换是存储当前正在运行的进程的状态并加载另一个进程的状态的过程。
老化是一种用于防止优先级调度中匮乏的技术。随着时间的推移，它会逐渐提高等待进程的优先级，从而确保优先级较低的进程最终获得 CPU 时间。

 ## process creation 进程创建
 a process (parent process) can create several new processes (the children of the process).
 大多数操作系统（包括 UNIX 、 Linux 和 Windows） 根据唯一的进程标识（或 pid）标识进程，该标识通常为整数。——process identifie

 -

    #include<stdio.h>
    #include<unistd.h>
    #include<sys/types.h> 
    int value = 5;
	int main()
	{
    pid t pid;
    pid = fork();
    if (pid == 0) { /* child process */ 
		value += 15;
		return 0;
    }
    else if (pid > 0) { /* parent process */
        wait(NULL);
        printf("PARENT: value = %d",value); /* LINE A */
        return 0;
	    }
	}
value 是一个全局变量，初始值为 5。
它在父进程和子进程中都存在，但它们在各自的内存空间中独立操作。即，子进程对 value 的修改不会影响父进程中的 value。

fork() 会创建一个子进程：子进程 得到一个与父进程相同的内存副本（包括 value 的初始值）。
父进程 的 pid 为子进程的进程 ID（正整数）。
子进程 的 pid 为 0。
子进程和父进程的内存是独立的。

So what is the output of LINE A?

- 
`fork()` 是用来创建一个新进程的系统调用。每次调用 `fork()` 时，都会创建一个新的进程，新的进程是父进程的副本。
`fork()` 会创建一个新进程，返回值有两个：

-   **父进程**：`fork()` 返回新创建子进程的 PID（进程 ID）。
-   **子进程**：`fork()` 返回 `0`。

	    #include <stdio.h> 
		#include <unistd.h>
		int main()
		{
	    /* fork a child process */
	    fork();
	    /* fork another child process */
	    fork();
	    /* and fork another */
	    fork();
	    return 0;
		}
第一次 `fork()` 调用后，会创建一个子进程。此时系统中有两个进程：父进程和第一个子进程。
第二次 `fork()` 调用后，所有现有进程（父进程和第一个子进程）都会各自创建一个新子进程。所以总进程数会翻倍。
第三次 `fork()` 调用时，所有现有的进程（包括父进程和前面创建的所有子进程）会再次各自创建一个新的子进程，进程数再次翻倍。
### 进程创建的详细分析：

1.  **第一次 `fork()`**：
    
    -   父进程调用 `fork()`，创建一个子进程。
    -   此时有两个进程：父进程和第一个子进程。
2.  **第二次 `fork()`**：
    
    -   父进程和第一个子进程都调用 `fork()`。
    -   父进程创建第二个子进程，子进程创建第三个子进程。
    -   此时共有 4 个进程：父进程、第一个子进程、第二个子进程、第三个子进程。
3.  **第三次 `fork()`**：
    
    -   父进程、第一个子进程、第二个子进程、第三个子进程都调用 `fork()`。
    -   每个进程创建一个新的子进程。
    -   此时共有 8 个进程：父进程和 7 个子进程。
   
  So including the initial parent process, how many processes are created by the program?

- **concurrent processing** 并发处理
> ### **并发进程是什么？**
> **并发**简单来说就是**“同时干很多事情”**。
举个例子：
.-   假如你是一个厨师，要同时煮饭、炒菜、煮汤。
    -   **煮饭**：米放锅里，让它煮着；
    -   **炒菜**：切菜、下锅翻炒；
    -   **煮汤**：水烧开，加入食材，慢慢炖。
你并不是“三头六臂”，而是**每件事轮流干一点**：
.1.  先把饭放锅里开始煮；
.2.  再切菜炒菜；
.3.  等汤烧开再去看一眼饭煮得怎么样。
>这就是并发进程！虽然每个时刻你只做一件事，但看起来就像你同时在煮饭、炒菜和煮汤。

----------

> ### **计算机里的并发进程**
> 
> 在电脑中：
> 
> 1.  一个进程是一个任务，比如“播放音乐”或“下载文件”。
> 2.  如果电脑只有一个CPU（就像只有一个厨师），它会像上面那样轮流干：
>     -   播放一小段音乐；
>     -   下载一点文件；
>     -   再回来播放下一小段音乐。
> 
> **结果**：虽然它是轮流干的，但速度很快，给我们的感觉就是“同时播放音乐”和“下载文件”。
在并发中，有几个问题需要注意：
> 
> 1.  **共享资源问题**  
>     假如两个进程同时修改一笔钱：
>     
>     -   进程A：要把钱取出来买东西；
>     -   进程B：要把钱取出来存到另一个账户。
>     
>     如果没有协调好，可能会出错（比如钱不翼而飞）。  
>     **解决方法**：需要“锁”来保证每次只能一个进程操作这笔钱。
>     
> 2.  **死锁（Deadlock）**  
>     假如两个进程同时需要两把钥匙：
>     
>     -   进程A拿了一把钥匙，等着另一把；
>     -   进程B拿了另一把钥匙，等着进程A的钥匙。
>     
>     两个进程都在等对方，谁也干不了活。  
>     **解决方法**：设计好规则，避免这种情况。
> >>>>### 总结
> 
> 1.  并发就是**轮流干活，看起来像同时干**。
> 2.  计算机利用并发提高效率，让多个任务“同时”运行。
> 3.  需要注意共享资源和死锁问题。

Concurrent Processes（并发进程）是指在同一时间段内，由操作系统调度和管理的多个进程，它们可能在同一时刻并行执行，也可能交替执行，但对用户来说，它们似乎是同时进行的。
并发性是多任务处理的一种形式，~~它允许多个任务（或进程）在计算机中共享资源，例如 CPU、内存和输入输出设备。~~并发进程的主要特征是在时间上重叠执行，而不一定是并行执行（即不一定同时在不同的处理器核心上执行）
**并发与并行的区别**

-   **并发（Concurrency）**：  
    轮流干活，像一个厨师切换任务，表面看起来同时在做。
    
-   **并行（Parallelism）**：  
    多个厨师（多核CPU）同时干活，比如一个厨师炒菜，一个厨师煮饭，真的同时进行。

Original versions of Apple’s mobile iOS operating system provided no means of concurrent processing. Discuss three major complications that concurrent processing adds to an operating system.

- **register set** 寄存器组
- **context switch** 上下文切换
<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyJoVk5hRTJscWVVT2lDNlA2Ijp7In
N0YXJ0IjozNTQ4LCJlbmQiOjM1ODAsInRleHQiOiJTbyB3aGF0
IGlzIHRoZSBvdXRwdXQgb2YgTElORSBBPyJ9LCJhZU9laEFJcV
RqdnNpOG5JIjp7InN0YXJ0Ijo0NTE4LCJlbmQiOjQ2MDUsInRl
eHQiOiJTbyBpbmNsdWRpbmcgdGhlIGluaXRpYWwgcGFyZW50IH
Byb2Nlc3MsIGhvdyBtYW55IHByb2Nlc3NlcyBhcmUgY3JlYXRl
ZCBieSB0aGXigKYifSwiT3dWNWNoaW1xZVJLSndXSSI6eyJzdG
FydCI6NTk3NCwiZW5kIjo2MTY0LCJ0ZXh0IjoiT3JpZ2luYWwg
dmVyc2lvbnMgb2YgQXBwbGXigJlzIG1vYmlsZSBpT1Mgb3Blcm
F0aW5nIHN5c3RlbSBwcm92aWRlZCBubyBtZWFucyBvZiBj4oCm
In19LCJjb21tZW50cyI6eyIzeTl2dmF2M1gwbHZ3dXpYIjp7Im
Rpc2N1c3Npb25JZCI6ImhWTmFFMmxxZVVPaUM2UDYiLCJzdWIi
OiJnbzoxMDUyOTEzMDU1MTM4Mjk5ODkwMDciLCJ0ZXh0IjoiUE
FSRU5U77yaIHZhbHVlID0gNSIsImNyZWF0ZWQiOjE3MzQ4NjA4
NDk1Mzh9LCJXYThMbE52aDBjaUJScVdDIjp7ImRpc2N1c3Npb2
5JZCI6ImhWTmFFMmxxZVVPaUM2UDYiLCJzdWIiOiJnbzoxMDUy
OTEzMDU1MTM4Mjk5ODkwMDciLCJ0ZXh0IjoiVGhlIHJlc3VsdC
BpcyBzdGlsbCA1LCBhcyB0aGUgY2hpbGQgdXBkYXRlcyBpdHMg
Y29weSBvZiB2YWx1ZS4gV2hlbiBjb250cm9sIHJldHVybnMgdG
8gdGhlIHBhcmVudCwgaXRzIHZhbHVlIHJlbWFpbnMgYXQgNS4i
LCJjcmVhdGVkIjoxNzM0ODYwODUzNzk0fSwiNEdkanlQaERZS1
ZPYkkyciI6eyJkaXNjdXNzaW9uSWQiOiJhZU9laEFJcVRqdnNp
OG5JIiwic3ViIjoiZ286MTA1MjkxMzA1NTEzODI5OTg5MDA3Ii
widGV4dCI6IjgiLCJjcmVhdGVkIjoxNzM0ODYxNjUxMzYyfSwi
Q0VZNXpCNUtWQlEyeXBlNiI6eyJkaXNjdXNzaW9uSWQiOiJPd1
Y1Y2hpbXFlUktKd1dJIiwic3ViIjoiZ286MTA1MjkxMzA1NTEz
ODI5OTg5MDA3IiwidGV4dCI6IlRoZSBDUFUgc2NoZWR1bGVyIG
11c3QgYmUgYXdhcmUgb2YgdGhlIGRpZmZlcmVudCBjb25jdXJy
ZW50IHByb2Nlc3NlcyBhbmQgbXVzdCBjaG9vc2UgYW4gYXBwcm
9wcmlhdGUgYWxnb3JpdGhtIHRoYXQgc2NoZWR1bGVzIHRoZSBj
b25jdXJyZW50IHByb2Nlc3Nlcy5DUFXosIPluqblmajpnIDopo
Hkuobop6PkuI3lkIznmoTlubblj5Hov5vnqIvvvIzlubbpgInm
i6nlkIjpgILnmoTnrpfms5XmnaXosIPluqbov5nkupvov5vnqI
vjgIIiLCJjcmVhdGVkIjoxNzM0OTk4MzYxNjg4fSwiazdCNExT
eW10T3lIcDVKVSI6eyJkaXNjdXNzaW9uSWQiOiJPd1Y1Y2hpbX
FlUktKd1dJIiwic3ViIjoiZ286MTA1MjkxMzA1NTEzODI5OTg5
MDA3IiwidGV4dCI6IuW5tuWPkei/m+eoi+WPr+iDvemcgOimge
ebuOS6kumAmuS/oe+8jOWboOatpOaTjeS9nOezu+e7n+W/hemh
u+aPkOS+m+S4gOenjeaIluWkmuenjei/m+eoi+mXtOmAmuS/oe
eahOaWueazleOAgkNvbmN1cnJlbnQgcHJvY2Vzc2VzIG1heSBu
ZWVkIHRvIGNvbW11bmljYXRlIHdpdGggb25lIGFub3RoZXIsIG
FuZCB0aGUgb3BlcmF0aW5nIHN5c3RlbSBtdXN0IHRoZXJlZm9y
ZSBkZXZlbG9wIG9uZSBvciBtb3JlIG1ldGhvZHMgZm9yIHByb3
ZpZGluZyBpbnRlcnByb2Nlc3MgY29tbXVuaWNhdGlvbi4qKui/
m+eoi+mXtOmAmuS/oe+8iElQQywgSW50ZXItUHJvY2VzcyBDb2
1tdW5pY2F0aW9u77yJKirvvJrlsLHmmK/lvZPkuIDkuKrov5vn
qIvpnIDopoHlkozlj6bkuIDkuKrov5vnqIvkuqTmjaLkv6Hmga
/ml7bvvIzmk43kvZzns7vnu5/pnIDopoHmj5DkvpvkuIDnp43m
lrnlvI/orqnlroPku6zmsp/pgJrjgIIiLCJjcmVhdGVkIjoxNz
M0OTk4NjczNzc2fSwiYXNyQkNqR0xIb1pUSDlvNiI6eyJkaXNj
dXNzaW9uSWQiOiJPd1Y1Y2hpbXFlUktKd1dJIiwic3ViIjoiZ2
86MTA1MjkxMzA1NTEzODI5OTg5MDA3IiwidGV4dCI6IueUseS6
juenu+WKqOiuvuWkh+mAmuW4uOWGheWtmOaciemZkO+8jOeuoe
eQhuS4jeWWhOeahOi/m+eoi+S8muWvueWFtuS7luW5tuWPkei/
m+eoi+S6p+eUn+i0n+mdouW9seWTjeOAguWboOatpO+8jOaTje
S9nOezu+e7n+W/hemhu+euoeeQhuWGheWtmO+8jOS7peaUr+aM
geWkmuS4quW5tuWPkei/m+eoi+OAgkJlY2F1c2UgbW9iaWxlIG
RldmljZXMgb2Z0ZW4gaGF2ZSBsaW1pdGVkIG1lbW9yeSwgYSBw
cm9jZXNzIHRoYXQgbWFuYWdlcyBtZW1vcnkgcG9vcmx5IHdpbG
wgaGF2ZSBhbiBvdmVyYWxsIG5lZ2F0aXZlIGltcGFjdCBvbiBv
dGhlciBjb25jdXJyZW50IHByb2Nlc3Nlcy4gVGhlIG9wZXJhdG
luZyBzeXN0ZW0gbXVzdCB0aGVyZWZvcmUgbWFuYWdlIG1lbW9y
eSB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcHJvY2
Vzc2VzLiIsImNyZWF0ZWQiOjE3MzQ5OTg5NzU3NTl9fSwiaGlz
dG9yeSI6WzkwODcxOTU0OSwyMTA2MTY1MzM2LDIxMzc0MTc2Nj
UsLTQzMjI5NTE1NywtMTk4NjE3MzcxMiwtMTM1MTY1MzE1Miwx
NjU1NTc0MjkwLDEwMDExMTAwMjgsLTE5NzA0NzMyMzksLTQ2OD
A1MDY1LC0xMDQ5MjkzNjIyLC0zNTcyMjAxMTIsMTExMzY5Mzc0
NCwtMTA1MDQ2NTYxOSw4NzU4MTA1ODIsLTMyNTM1MTE1M119
-->